<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gráfico de Rehabilitación de Vía</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        #plot {
            width: 90%;
            margin: auto;
            height: 800px;
        }
        #tramButtons {
            width: 90%;
            margin: 20px auto;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        .tram-button {
            padding: 10px 15px;
            background-color: lightgray;
            border: none;
            cursor: pointer;
            font-family: Arial, sans-serif;
            transition: background-color 0.3s;
        }
        .tram-button:hover {
            background-color: #d3d3d3;
        }
        .tram-button.selected {
            background-color: #007bff;
            color: white;
        }
    </style>
</head>
<body>
    <h1>Gráfico de Rehabilitación de Vía</h1>
    <div id="tramButtons"></div>
    <div id="plot"></div>

    <script>
        async function loadData(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const data = await response.json();
                return data;
            } catch (error) {
                console.error(`Error cargando datos de ${url}:`, error);
            }
        }

        function groupConsecutiveSegments(data) {
            const groupedData = [];
            let currentGroup = null;

            data.forEach(segment => {
                const pkInici = parseFloat(segment['PK inici']);
                const pkFinal = parseFloat(segment['PK final']);
                const previsio = segment['PREVISIÓ REHABILITACIÓ'];

                if (
                    currentGroup &&
                    currentGroup.PKFinal === pkInici &&
                    currentGroup.PREVISIO === previsio
                ) {
                    // Si el segmento es consecutivo y del mismo año, se añade al grupo actual
                    currentGroup.PKFinal = pkFinal;
                    currentGroup.length += (pkFinal - pkInici) * 1000;
                } else {
                    // Si no, se cierra el grupo actual y se comienza uno nuevo
                    if (currentGroup) {
                        groupedData.push(currentGroup);
                    }
                    currentGroup = {
                        PKInici: pkInici,
                        PKFinal: pkFinal,
                        PREVISIO: previsio,
                        length: (pkFinal - pkInici) * 1000,
                        via: segment.Via
                    };
                }
            });

            // Añadir el último grupo si existe
            if (currentGroup) {
                groupedData.push(currentGroup);
            }

            return groupedData;
        }

        async function drawPlot(tram) {
            const resumUrl = 'https://raw.githubusercontent.com/cvazquezfgc/planificacio-renovacio-via/main/resum.json';
            const estacionsUrl = 'https://raw.githubusercontent.com/cvazquezfgc/planificacio-renovacio-via/main/estacions.json';

            const resumData = await loadData(resumUrl);
            const estacionsData = await loadData(estacionsUrl);

            if (!resumData || !estacionsData) {
                console.error('Los datos no pudieron ser cargados.');
                return;
            }

            // Filtrar los datos específicos para el tramo seleccionado
            const via1Data = resumData.filter(d => parseInt(d.Via) === 1 && d.TRAM === tram);
            const via2Data = resumData.filter(d => parseInt(d.Via) === 2 && d.TRAM === tram);
            const estaciones = estacionsData.filter(d => d.Tram === tram);

            if (via1Data.length === 0 && via2Data.length === 0) {
                console.error(`No se encontraron datos para el tramo ${tram}.`);
                Plotly.newPlot('plot', [], { title: `No hay datos disponibles para el tramo ${tram}` });
                return;
            }

            // Agrupar segmentos consecutivos
            const via1 = groupConsecutiveSegments(via1Data);
            const via2 = groupConsecutiveSegments(via2Data);

            // Crear datos para las barras de "Vía 1" y "Vía 2"
            const traceVia1 = {
                x: via1.map(d => d.PREVISIO),
                y: via1.map(d => d.PKFinal - d.PKInici),
                base: via1.map(d => d.PKInici),
                type: 'bar',
                name: 'Vía 1',
                orientation: 'v',
                width: 0.5,
                offset: 0.0,
                marker: {
                    color: 'rgba(31, 119, 180, 1)'
                },
                hoverinfo: 'text',
                hovertext: via1.map(d => `${Math.round(d.length)} m`),
                textposition: 'outside'
            };

            const traceVia2 = {
                x: via2.map(d => d.PREVISIO),
                y: via2.map(d => d.PKFinal - d.PKInici),
                base: via2.map(d => d.PKInici),
                type: 'bar',
                name: 'Vía 2',
                orientation: 'v',
                width: 0.5,
                offset: 0.5,
                marker: {
                    color: 'rgba(255, 127, 14, 1)'
                },
                hoverinfo: 'text',
                hovertext: via2.map(d => `${Math.round(d.length)} m`),
                textposition: 'outside'
            };

            // Añadir líneas y etiquetas para las estaciones
            const stationLines = estaciones.map(d => ({
                type: 'line',
                x0: 1998,
                x1: 2069,
                y0: parseFloat(d['PK']),
                y1: parseFloat(d['PK']),
                line: {
                    color: 'darkgray',
                    width: 1.5,
                    layer: 'below'
                }
            }));

            const stationAnnotations = estaciones.map(d => ({
                x: 2068,
                y: parseFloat(d['PK']),
                text: `<b>${d['Abreviatura']}</b>`,
                showarrow: false,
                font: {
                    color: 'black',
                    size: 14,
                    family: 'Arial, sans-serif'
                },
                xanchor: 'center',
                yanchor: 'middle',
                bgcolor: 'white',
                bordercolor: 'gray',
                borderwidth: 2,
                borderpad: 5,
                opacity: 1
            }));

            // Añadir líneas verticales y sombreado de años
            const yearLines = Array.from({ length: 71 }, (_, i) => 1998 + i).map(year => ({
                type: 'line',
                x0: year,
                x1: year,
                y0: Math.min(...resumData.map(d => parseFloat(d['PK inici']))),
                y1: Math.max(...resumData.map(d => parseFloat(d['PK final']))),
                line: {
                    color: 'lightgray',
                    width: 0.8,
                    layer: 'below'
                }
            }));

            const shadedYears = Array.from({ length: 71 }, (_, i) => 1998 + i).filter(year => year % 5 === 0).map(year => ({
                type: 'rect',
                x0: year,
                x1: year + 1,
                                y0: Math.min(...resumData.map(d => parseFloat(d['PK inici']))),
                y1: Math.max(...resumData.map(d => parseFloat(d['PK final']))),
                fillcolor: 'rgba(211, 211, 211, 0.3)',
                layer: 'below',
                line: {
                    width: 0
                }
            }));

            // Añadir líneas horizontales para los PKs
            const pkRange = [];
            const pkMin = Math.floor(Math.min(...resumData.filter(d => d.TRAM === tram).map(d => parseFloat(d['PK inici']))));
            const pkMax = Math.ceil(Math.max(...resumData.filter(d => d.TRAM === tram).map(d => parseFloat(d['PK final']))));
            for (let pk = pkMin; pk <= pkMax; pk++) {
                pkRange.push(pk);
            }

            const pkLines = pkRange.map(pk => ({
                type: 'line',
                x0: 1998,
                x1: 2069,
                y0: pk,
                y1: pk,
                line: {
                    color: 'lightgray',
                    width: 1,
                    layer: 'below'
                }
            }));

            // Configuración del gráfico
            const layout = {
                title: `Espai-temps previsió rehabilitació del tram ${tram}`,
                titlefont: {
                    family: 'Arial, sans-serif',
                    size: 18,
                    color: 'black'
                },
                xaxis: {
                    title: 'Any previsió rehabilitació',
                    titlefont: {
                        size: 20,
                        color: 'black',
                        family: 'Arial, sans-serif',
                        weight: 'bold'
                    },
                    tickangle: -45,
                    range: [1998, 2069],
                    tickvals: Array.from({ length: 71 }, (_, i) => 1998 + i).filter(year => year % 5 === 0)
                },
                yaxis: {
                    title: 'PK',
                    titlefont: {
                        size: 20,
                        color: 'black',
                        family: 'Arial, sans-serif',
                        weight: 'bold'
                    },
                    tickvals: pkRange,
                    ticktext: pkRange.map(pk => `${pk}+000`),
                    range: [pkMax, pkMin],
                    autorange: 'reversed'
                },
                shapes: [...shadedYears, ...yearLines, ...pkLines, ...stationLines],
                annotations: stationAnnotations,
                margin: {
                    l: 120,
                    r: 180,
                    t: 80,
                    b: 150
                },
                showlegend: true,
                hovermode: 'closest' // Configurar para que sólo se muestre el hover de la barra más cercana
            };

            // Dibujar la gráfica con los datos, asegurando que las barras estén por encima de todo lo demás
            Plotly.newPlot('plot', [traceVia1, traceVia2], layout);
        }

        // Inicializar la página y eventos
        document.addEventListener('DOMContentLoaded', async function () {
            // Cargar la lista de tramos y crear los botones de selección
            const resumUrl = 'https://raw.githubusercontent.com/cvazquezfgc/planificacio-renovacio-via/main/resum.json';
            const resumData = await loadData(resumUrl);
            const tramButtonsContainer = document.getElementById('tramButtons');

            if (!resumData) {
                console.error('Error al cargar los datos para llenar los botones de tramo.');
                return;
            }

            // Obtener todos los tramos únicos
            const trams = [...new Set(resumData.map(d => d.TRAM))];

            // Añadir botones al contenedor para cada tramo
            trams.forEach(tram => {
                if (tram) {
                    const button = document.createElement('button');
                    button.className = 'tram-button';
                    button.textContent = tram;
                    button.addEventListener('click', () => {
                        // Quitar la clase "selected" de todos los botones
                        document.querySelectorAll('.tram-button').forEach(btn => btn.classList.remove('selected'));

                        // Añadir la clase "selected" al botón actual
                        button.classList.add('selected');

                        // Dibujar el gráfico del tramo seleccionado
                        drawPlot(tram);
                    });
                    tramButtonsContainer.appendChild(button);
                }
            });

            // Dibujar el gráfico inicialmente para el primer tramo
            if (trams.length > 0) {
                document.querySelector('.tram-button').classList.add('selected');
                drawPlot(trams[0]);
            } else {
                console.error('No se encontraron tramos disponibles en los datos.');
            }
        });
    </script>
</body>
</html>

